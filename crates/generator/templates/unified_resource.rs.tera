//! {{ resource.name | capitalize }} resource
//!
//! {{ resource.description | default(value="Auto-generated resource") }}

use tracing::{debug, error, info, warn};

{% if provider | has_config_crate %}
/// Create a new {{ resource.name }}
pub async fn create(
    client: {{ provider | client_type(service_name=service_name) }},
    input: serde_json::Value,
) -> Result<serde_json::Value, String> {
    info!("Creating {{ resource.name }}");
    debug!("Input: {:?}", input);

    // Validate required fields
{% for field in resource.fields %}
{% if field.required %}
    if input.get("{{ field.name }}").is_none() {
        return Err("Missing required field: {{ field.name }}".to_string());
    }
{% endif %}
{% endfor %}

{% if resource.operations.create %}
    // Build the SDK request
    let mut request = client.{{ resource.operations.create.sdk_operation }}();

    // Set required fields
{% for field in resource.fields %}
{% if field.required %}
    if let Some(val) = input.get("{{ field.name }}") {
{% if field.field_type == "String" %}
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
{% elif field.field_type == "Integer" %}
        if let Some(n) = val.as_i64() {
            request = request.{{ field.name }}(n as i32);
        }
{% elif field.field_type == "Boolean" %}
        if let Some(b) = val.as_bool() {
            request = request.{{ field.name }}(b);
        }
{% elif field.field_type == "Float" %}
        if let Some(n) = val.as_f64() {
            request = request.{{ field.name }}(n);
        }
{% elif field.field_type.List is defined %}
        if let Some(arr) = val.as_array() {
            let items: Vec<String> = arr.iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect();
            request = request.{{ field.name }}(items);
        }
{% else %}
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
{% endif %}
    }
{% endif %}
{% endfor %}

    // Set optional fields
{% for field in resource.fields %}
{% if not field.required %}
    if let Some(val) = input.get("{{ field.name }}") {
{% if field.field_type == "String" %}
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
{% elif field.field_type == "Integer" %}
        if let Some(n) = val.as_i64() {
            request = request.{{ field.name }}(n as i32);
        }
{% elif field.field_type == "Boolean" %}
        if let Some(b) = val.as_bool() {
            request = request.{{ field.name }}(b);
        }
{% elif field.field_type == "Float" %}
        if let Some(n) = val.as_f64() {
            request = request.{{ field.name }}(n);
        }
{% elif field.field_type.List is defined %}
        if let Some(arr) = val.as_array() {
            let items: Vec<String> = arr.iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect();
            request = request.{{ field.name }}(items);
        }
{% else %}
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
{% endif %}
    }
{% endif %}
{% endfor %}

    // Set nested blocks
{% for block in resource.blocks %}
    // {{ block.name }} block
    if let Some(block_data) = input.get("{{ block.name }}") {
{% if block.sdk_type_name and block.sdk_accessor_method %}
{% if block.nesting_mode == "NestingMode::List" %}
        // List of {{ block.name }} blocks
        if let Some(items) = block_data.as_array() {
            let mut block_items = Vec::new();
            for item in items {
                // Build {{ block.sdk_type_name }} from JSON
                let mut builder = {{ provider | sdk_crate_module(service_name=service_name) }}::types::{{ block.sdk_type_name }}::builder();

{% for attr in block.attributes %}
                if let Some(val) = item.get("{{ attr.name }}") {
{% if attr.field_type == "String" %}
                    if let Some(s) = val.as_str() {
                        builder = builder.{{ attr.name }}(s);
                    }
{% elif attr.field_type == "Integer" %}
                    if let Some(n) = val.as_i64() {
                        builder = builder.{{ attr.name }}(n as i32);
                    }
{% elif attr.field_type == "Boolean" %}
                    if let Some(b) = val.as_bool() {
                        builder = builder.{{ attr.name }}(b);
                    }
{% elif attr.field_type == "Float" %}
                    if let Some(f) = val.as_f64() {
                        builder = builder.{{ attr.name }}(f);
                    }
{% else %}
                    if let Some(s) = val.as_str() {
                        builder = builder.{{ attr.name }}(s);
                    }
{% endif %}
                }
{% endfor %}

                if let Ok(built) = builder.build() {
                    block_items.push(built);
                }
            }
            if !block_items.is_empty() {
                request = request.{{ block.sdk_accessor_method }}(block_items);
            }
        }
{% else %}
        // Single {{ block.name }} block
        let mut builder = {{ provider | sdk_crate_module(service_name=service_name) }}::types::{{ block.sdk_type_name }}::builder();

{% for attr in block.attributes %}
        if let Some(val) = block_data.get("{{ attr.name }}") {
{% if attr.field_type == "String" %}
            if let Some(s) = val.as_str() {
                builder = builder.{{ attr.name }}(s);
            }
{% elif attr.field_type == "Integer" %}
            if let Some(n) = val.as_i64() {
                builder = builder.{{ attr.name }}(n as i32);
            }
{% elif attr.field_type == "Boolean" %}
            if let Some(b) = val.as_bool() {
                builder = builder.{{ attr.name }}(b);
            }
{% elif attr.field_type == "Float" %}
            if let Some(f) = val.as_f64() {
                builder = builder.{{ attr.name }}(f);
            }
{% else %}
            if let Some(s) = val.as_str() {
                builder = builder.{{ attr.name }}(s);
            }
{% endif %}
        }
{% endfor %}

        if let Ok(built) = builder.build() {
            request = request.{{ block.sdk_accessor_method }}(built);
        }
{% endif %}
{% else %}
        // SDK metadata not available for {{ block.name }} - skipping
        warn!("Nested block {{ block.name }} detected but SDK metadata not available");
{% endif %}
    }
{% endfor %}

    // Execute the request
    match request.send().await {
        Ok(response) => {
            info!("Successfully created {{ resource.name }}");
            debug!("Response: {:?}", response);

            // Build output state with computed fields extracted from response
            let mut output = input.clone();
            if let Some(obj) = output.as_object_mut() {
{% for output_field in resource.outputs %}
{% if output_field.response_accessor %}
                // Extract {{ output_field.name }} from response.{{ output_field.response_accessor }}()
{% if output_field.field_type == "String" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::String(val.to_string()),
                    );
                }
{% elif output_field.field_type == "Integer" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::Number(serde_json::Number::from(*val)),
                    );
                }
{% elif output_field.field_type == "Boolean" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::Bool(*val),
                    );
                }
{% elif output_field.field_type == "Float" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    if let Some(num) = serde_json::Number::from_f64(*val) {
                        obj.insert(
                            "{{ output_field.name }}".to_string(),
                            serde_json::Value::Number(num),
                        );
                    }
                }
{% else %}
                // Complex type - attempt string conversion
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::String(format!("{:?}", val)),
                    );
                }
{% endif %}
{% else %}
                // No accessor defined for {{ output_field.name }} - use placeholder
                obj.insert(
                    "{{ output_field.name }}".to_string(),
                    serde_json::Value::String(format!("computed-{{ output_field.name }}")),
                );
{% endif %}
{% endfor %}
            }

            Ok(output)
        }
        Err(e) => {
            error!("Failed to create {{ resource.name }}: {:?}", e);
            Err(format!("Failed to create {{ resource.name }}: {}", e))
        }
    }
{% else %}
    // No create operation defined
    warn!("Create operation not defined for {{ resource.name }}");
    Ok(input)
{% endif %}
}

/// Read a {{ resource.name }}
pub async fn read(
    client: {{ provider | client_type(service_name=service_name) }},
    current: serde_json::Value,
) -> Result<serde_json::Value, String> {
    debug!("Reading {{ resource.name }}");

{% if resource.operations.read %}
    // Build the SDK request
    let mut request = client.{{ resource.operations.read.sdk_operation }}();

    // Set identifier fields from current state
{% for field in resource.fields %}
{% if field.required and field.immutable %}
    if let Some(val) = current.get("{{ field.name }}") {
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
    }
{% endif %}
{% endfor %}

    match request.send().await {
        Ok(response) => {
            debug!("Read response: {:?}", response);

            // Update state with values from response
            let mut state = current.clone();
            if let Some(obj) = state.as_object_mut() {
{% for output_field in resource.outputs %}
{% if output_field.response_accessor %}
{% if output_field.field_type == "String" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::String(val.to_string()),
                    );
                }
{% elif output_field.field_type == "Integer" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::Number(serde_json::Number::from(*val)),
                    );
                }
{% elif output_field.field_type == "Boolean" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::Bool(*val),
                    );
                }
{% elif output_field.field_type == "Float" %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    if let Some(num) = serde_json::Number::from_f64(*val) {
                        obj.insert(
                            "{{ output_field.name }}".to_string(),
                            serde_json::Value::Number(num),
                        );
                    }
                }
{% else %}
                if let Some(val) = response.{{ output_field.response_accessor }}() {
                    obj.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::String(format!("{:?}", val)),
                    );
                }
{% endif %}
{% endif %}
{% endfor %}
            }

            Ok(state)
        }
        Err(e) => {
            warn!("Failed to read {{ resource.name }}: {:?}", e);
            // Return current state on read failure (resource may have been deleted)
            Ok(current)
        }
    }
{% else %}
    // No read operation defined
    Ok(current)
{% endif %}
}

/// Update a {{ resource.name }}
pub async fn update(
    client: {{ provider | client_type(service_name=service_name) }},
    input: serde_json::Value,
) -> Result<serde_json::Value, String> {
    info!("Updating {{ resource.name }}");
    debug!("Input: {:?}", input);

{% if resource.operations.update %}
    // Build the SDK request
    let mut request = client.{{ resource.operations.update.sdk_operation }}();

    // Set identifier fields (immutable)
{% for field in resource.fields %}
{% if field.required and field.immutable %}
    if let Some(val) = input.get("{{ field.name }}") {
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
    }
{% endif %}
{% endfor %}

    // Set updatable fields
{% for field in resource.fields %}
{% if not field.immutable %}
    if let Some(val) = input.get("{{ field.name }}") {
{% if field.field_type == "String" %}
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
{% elif field.field_type == "Integer" %}
        if let Some(n) = val.as_i64() {
            request = request.{{ field.name }}(n as i32);
        }
{% elif field.field_type == "Boolean" %}
        if let Some(b) = val.as_bool() {
            request = request.{{ field.name }}(b);
        }
{% elif field.field_type == "Float" %}
        if let Some(n) = val.as_f64() {
            request = request.{{ field.name }}(n);
        }
{% else %}
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
{% endif %}
    }
{% endif %}
{% endfor %}

    // Set nested blocks
{% for block in resource.blocks %}
    // {{ block.name }} block
    if let Some(block_data) = input.get("{{ block.name }}") {
{% if block.sdk_type_name and block.sdk_accessor_method %}
{% if block.nesting_mode == "NestingMode::List" %}
        // List of {{ block.name }} blocks
        if let Some(items) = block_data.as_array() {
            let mut block_items = Vec::new();
            for item in items {
                // Build {{ block.sdk_type_name }} from JSON
                let mut builder = {{ provider | sdk_crate_module(service_name=service_name) }}::types::{{ block.sdk_type_name }}::builder();

{% for attr in block.attributes %}
                if let Some(val) = item.get("{{ attr.name }}") {
{% if attr.field_type == "String" %}
                    if let Some(s) = val.as_str() {
                        builder = builder.{{ attr.name }}(s);
                    }
{% elif attr.field_type == "Integer" %}
                    if let Some(n) = val.as_i64() {
                        builder = builder.{{ attr.name }}(n as i32);
                    }
{% elif attr.field_type == "Boolean" %}
                    if let Some(b) = val.as_bool() {
                        builder = builder.{{ attr.name }}(b);
                    }
{% elif attr.field_type == "Float" %}
                    if let Some(f) = val.as_f64() {
                        builder = builder.{{ attr.name }}(f);
                    }
{% else %}
                    if let Some(s) = val.as_str() {
                        builder = builder.{{ attr.name }}(s);
                    }
{% endif %}
                }
{% endfor %}

                if let Ok(built) = builder.build() {
                    block_items.push(built);
                }
            }
            if !block_items.is_empty() {
                request = request.{{ block.sdk_accessor_method }}(block_items);
            }
        }
{% else %}
        // Single {{ block.name }} block
        let mut builder = {{ provider | sdk_crate_module(service_name=service_name) }}::types::{{ block.sdk_type_name }}::builder();

{% for attr in block.attributes %}
        if let Some(val) = block_data.get("{{ attr.name }}") {
{% if attr.field_type == "String" %}
            if let Some(s) = val.as_str() {
                builder = builder.{{ attr.name }}(s);
            }
{% elif attr.field_type == "Integer" %}
            if let Some(n) = val.as_i64() {
                builder = builder.{{ attr.name }}(n as i32);
            }
{% elif attr.field_type == "Boolean" %}
            if let Some(b) = val.as_bool() {
                builder = builder.{{ attr.name }}(b);
            }
{% elif attr.field_type == "Float" %}
            if let Some(f) = val.as_f64() {
                builder = builder.{{ attr.name }}(f);
            }
{% else %}
            if let Some(s) = val.as_str() {
                builder = builder.{{ attr.name }}(s);
            }
{% endif %}
        }
{% endfor %}

        if let Ok(built) = builder.build() {
            request = request.{{ block.sdk_accessor_method }}(built);
        }
{% endif %}
{% else %}
        // SDK metadata not available for {{ block.name }} - skipping
        warn!("Nested block {{ block.name }} detected but SDK metadata not available");
{% endif %}
    }
{% endfor %}

    match request.send().await {
        Ok(response) => {
            info!("Successfully updated {{ resource.name }}");
            debug!("Response: {:?}", response);
            Ok(input)
        }
        Err(e) => {
            error!("Failed to update {{ resource.name }}: {:?}", e);
            Err(format!("Failed to update {{ resource.name }}: {}", e))
        }
    }
{% else %}
    // No update operation defined
    warn!("Update operation not defined for {{ resource.name }}");
    Ok(input)
{% endif %}
}

/// Delete a {{ resource.name }}
pub async fn delete(
    client: {{ provider | client_type(service_name=service_name) }},
    current: serde_json::Value,
) -> Result<(), String> {
    info!("Deleting {{ resource.name }}");
    debug!("Current state: {:?}", current);

{% if resource.operations.delete %}
    // Build the SDK request
    let mut request = client.{{ resource.operations.delete.sdk_operation }}();

    // Set identifier fields
{% for field in resource.fields %}
{% if field.required and field.immutable %}
    if let Some(val) = current.get("{{ field.name }}") {
        if let Some(s) = val.as_str() {
            request = request.{{ field.name }}(s);
        }
    }
{% endif %}
{% endfor %}

    match request.send().await {
        Ok(_) => {
            info!("Successfully deleted {{ resource.name }}");
            Ok(())
        }
        Err(e) => {
            error!("Failed to delete {{ resource.name }}: {:?}", e);
            Err(format!("Failed to delete {{ resource.name }}: {}", e))
        }
    }
{% else %}
    // No delete operation defined
    warn!("Delete operation not defined for {{ resource.name }}");
    Ok(())
{% endif %}
}

/// Import an existing {{ resource.name }}
pub async fn import(
    client: {{ provider | client_type(service_name=service_name) }},
    id: &str,
) -> Result<Vec<hemmer_provider_sdk::ImportedResource>, hemmer_provider_sdk::ProviderError> {
    info!("Importing {{ resource.name }} with id: {}", id);

{% if resource.operations.import or resource.operations.read %}
    // Build the SDK request using import or read operation
    let mut request = client.{{ resource.operations.import.sdk_operation | default(value=resource.operations.read.sdk_operation) }}();

    // Set the ID field
{% if resource.id_field %}
    request = request.{{ resource.id_field }}(id);
{% else %}
    // Default to first required+immutable field
{% for field in resource.fields %}
{% if field.required and field.immutable %}
    request = request.{{ field.name }}(id);
{% break %}
{% endif %}
{% endfor %}
{% endif %}

    match request.send().await {
        Ok(response) => {
            debug!("Successfully imported {{ resource.name }}");

            // Build state from response
            let mut state = serde_json::Map::new();

            // Set the ID field
{% if resource.id_field %}
            state.insert("{{ resource.id_field }}".to_string(), serde_json::Value::String(id.to_string()));
{% else %}
{% for field in resource.fields %}
{% if field.required and field.immutable %}
            state.insert("{{ field.name }}".to_string(), serde_json::Value::String(id.to_string()));
{% break %}
{% endif %}
{% endfor %}
{% endif %}

            // Extract output fields from response
{% for output_field in resource.outputs %}
{% if output_field.response_accessor %}
{% if output_field.field_type == "String" %}
            if let Some(val) = response.{{ output_field.response_accessor }}() {
                state.insert(
                    "{{ output_field.name }}".to_string(),
                    serde_json::Value::String(val.to_string()),
                );
            }
{% elif output_field.field_type == "Integer" %}
            if let Some(val) = response.{{ output_field.response_accessor }}() {
                state.insert(
                    "{{ output_field.name }}".to_string(),
                    serde_json::Value::Number(serde_json::Number::from(*val)),
                );
            }
{% elif output_field.field_type == "Boolean" %}
            if let Some(val) = response.{{ output_field.response_accessor }}() {
                state.insert(
                    "{{ output_field.name }}".to_string(),
                    serde_json::Value::Bool(*val),
                );
            }
{% elif output_field.field_type == "Float" %}
            if let Some(val) = response.{{ output_field.response_accessor }}() {
                if let Some(num) = serde_json::Number::from_f64(*val) {
                    state.insert(
                        "{{ output_field.name }}".to_string(),
                        serde_json::Value::Number(num),
                    );
                }
            }
{% else %}
            if let Some(val) = response.{{ output_field.response_accessor }}() {
                state.insert(
                    "{{ output_field.name }}".to_string(),
                    serde_json::Value::String(format!("{:?}", val)),
                );
            }
{% endif %}
{% endif %}
{% endfor %}

            Ok(vec![hemmer_provider_sdk::ImportedResource::new(
                "{{ resource.name }}",
                serde_json::Value::Object(state),
            )])
        }
        Err(e) => {
            error!("Failed to import {{ resource.name }}: {:?}", e);
            Err(hemmer_provider_sdk::ProviderError::Sdk(format!("Failed to import: {}", e)))
        }
    }
{% else %}
    Err(hemmer_provider_sdk::ProviderError::Unimplemented(format!(
        "Import not supported for {{ resource.name }}"
    )))
{% endif %}
}

{% else %}
use std::collections::HashMap;

/// Create a new {{ resource.name }}
pub async fn create(
    config: &HashMap<String, String>,
    input: serde_json::Value,
) -> Result<serde_json::Value, String> {
    info!("Creating {{ resource.name }}");
    debug!("Input: {:?}", input);

    // Validate required fields
{% for field in resource.fields %}
{% if field.required %}
    if input.get("{{ field.name }}").is_none() {
        return Err("Missing required field: {{ field.name }}".to_string());
    }
{% endif %}
{% endfor %}

    // TODO: Implement {{ provider }} SDK calls
    let mut output = input.clone();
    if let Some(obj) = output.as_object_mut() {
{% for output_field in resource.outputs %}
        obj.insert(
            "{{ output_field.name }}".to_string(),
            serde_json::Value::String(format!("computed-{{ output_field.name }}")),
        );
{% endfor %}
    }

    Ok(output)
}

/// Read a {{ resource.name }}
pub async fn read(
    config: &HashMap<String, String>,
    current: serde_json::Value,
) -> Result<serde_json::Value, String> {
    debug!("Reading {{ resource.name }}");
    // TODO: Implement {{ provider }} SDK calls
    Ok(current)
}

/// Update a {{ resource.name }}
pub async fn update(
    config: &HashMap<String, String>,
    input: serde_json::Value,
) -> Result<serde_json::Value, String> {
    info!("Updating {{ resource.name }}");
    // TODO: Implement {{ provider }} SDK calls
    Ok(input)
}

/// Delete a {{ resource.name }}
pub async fn delete(
    config: &HashMap<String, String>,
    current: serde_json::Value,
) -> Result<(), String> {
    info!("Deleting {{ resource.name }}");
    // TODO: Implement {{ provider }} SDK calls
    Ok(())
}

/// Import an existing {{ resource.name }}
pub async fn import(
    config: &HashMap<String, String>,
    id: &str,
) -> Result<Vec<hemmer_provider_sdk::ImportedResource>, hemmer_provider_sdk::ProviderError> {
    info!("Importing {{ resource.name }} with id: {}", id);
    // TODO: Implement {{ provider }} SDK calls for import
    Err(hemmer_provider_sdk::ProviderError::Unimplemented(format!(
        "Import not implemented for {{ resource.name }}"
    )))
}
{% endif %}

#[cfg(test)]
mod tests {
    #[test]
    fn test_{{ resource.name | sanitize_identifier_part }}_placeholder() {
        // Placeholder test for {{ resource.name }}
        // Real tests would require SDK mocking
        assert!(true);
    }
}
