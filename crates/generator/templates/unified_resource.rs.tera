//! {{ resource.name | capitalize }} resource
//!
//! {{ resource.description | default(value="Auto-generated resource") }}

use std::collections::HashMap;

/// Create a new {{ resource.name }}
#[allow(unused_variables)]
pub async fn create(
    config: &HashMap<String, String>,
    input: serde_json::Value,
) -> Result<serde_json::Value, String> {
{% if provider == "Aws" %}
    // Extract input fields
{% for field in resource.fields %}
{% if field.required %}
    let {{ field.name }} = input.get("{{ field.name }}")
        .and_then(|v| v.as_str())
        .ok_or_else(|| "Missing required field: {{ field.name }}".to_string())?;
{% else %}
    let {{ field.name }} = input.get("{{ field.name }}")
        .and_then(|v| v.as_str());
{% endif %}
{% endfor %}

    // TODO: Initialize AWS SDK client using config
    // let sdk_config = aws_config::from_env()
    //     .region(config.get("region").map(|s| Region::new(s.clone())))
    //     .load()
    //     .await;
    // let client = aws_sdk_{{ service_name }}::Client::new(&sdk_config);

    // TODO: Call AWS SDK to create the resource
    // let result = client
    //     .create_{{ resource.name }}()
{% for field in resource.fields %}
    //     .{{ field.name }}({{ field.name }})
{% endfor %}
    //     .send()
    //     .await
    //     .map_err(|e| format!("Failed to create {{ resource.name }}: {}", e))?;

    // Return placeholder output with computed fields
    let mut output = input.clone();
{% for output_field in resource.outputs %}
    output.as_object_mut()
        .ok_or_else(|| "Invalid input format".to_string())?
        .insert("{{ output_field.name }}".to_string(), serde_json::json!("placeholder-{{ output_field.name }}"));
{% endfor %}

    Ok(output)
{% else %}
    // TODO: Implement create for {{ provider }}
    Err("Not implemented".to_string())
{% endif %}
}

/// Read a {{ resource.name }}
#[allow(unused_variables)]
pub async fn read(
    config: &HashMap<String, String>,
    current: serde_json::Value,
) -> Result<serde_json::Value, String> {
{% if provider == "Aws" %}
    // TODO: Initialize AWS SDK client using config
    // let sdk_config = aws_config::from_env()
    //     .region(config.get("region").map(|s| Region::new(s.clone())))
    //     .load()
    //     .await;
    // let client = aws_sdk_{{ service_name }}::Client::new(&sdk_config);

    // TODO: Call AWS SDK to read the resource
    // Extract identifier from current state
    // let id = current.get("id").and_then(|v| v.as_str());
    // let result = client
    //     .describe_{{ resource.name }}()
    //     .send()
    //     .await
    //     .map_err(|e| format!("Failed to read {{ resource.name }}: {}", e))?;

    // Return current state (refresh would update from API)
    Ok(current)
{% else %}
    // TODO: Implement read for {{ provider }}
    Err("Not implemented".to_string())
{% endif %}
}

/// Update a {{ resource.name }}
#[allow(unused_variables)]
pub async fn update(
    config: &HashMap<String, String>,
    input: serde_json::Value,
) -> Result<serde_json::Value, String> {
{% if provider == "Aws" %}
    // Extract input fields
{% for field in resource.fields %}
{% if not field.immutable %}
    let {{ field.name }} = input.get("{{ field.name }}")
        .and_then(|v| v.as_str());
{% endif %}
{% endfor %}

    // TODO: Initialize AWS SDK client using config
    // let sdk_config = aws_config::from_env()
    //     .region(config.get("region").map(|s| Region::new(s.clone())))
    //     .load()
    //     .await;
    // let client = aws_sdk_{{ service_name }}::Client::new(&sdk_config);

    // TODO: Call AWS SDK to update the resource
    // let result = client
    //     .update_{{ resource.name }}()
{% for field in resource.fields %}
{% if not field.immutable %}
    //     .{{ field.name }}({{ field.name }})
{% endif %}
{% endfor %}
    //     .send()
    //     .await
    //     .map_err(|e| format!("Failed to update {{ resource.name }}: {}", e))?;

    // Return updated state
    Ok(input)
{% else %}
    // TODO: Implement update for {{ provider }}
    Err("Not implemented".to_string())
{% endif %}
}

/// Delete a {{ resource.name }}
#[allow(unused_variables)]
pub async fn delete(
    config: &HashMap<String, String>,
    current: serde_json::Value,
) -> Result<(), String> {
{% if provider == "Aws" %}
    // TODO: Initialize AWS SDK client using config
    // let sdk_config = aws_config::from_env()
    //     .region(config.get("region").map(|s| Region::new(s.clone())))
    //     .load()
    //     .await;
    // let client = aws_sdk_{{ service_name }}::Client::new(&sdk_config);

    // TODO: Call AWS SDK to delete the resource
    // Extract identifier from current state
    // let id = current.get("id").and_then(|v| v.as_str());
    // client
    //     .delete_{{ resource.name }}()
    //     .send()
    //     .await
    //     .map_err(|e| format!("Failed to delete {{ resource.name }}: {}", e))?;

    Ok(())
{% else %}
    // TODO: Implement delete for {{ provider }}
    Err("Not implemented".to_string())
{% endif %}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_{{ resource.name }}_create() {
        // Test {{ resource.name }} create operation
        let config = HashMap::new();
        let input = serde_json::json!({
{% for field in resource.fields %}
            "{{ field.name }}": "test-value",
{% endfor %}
        });

        // Note: This will fail without actual AWS credentials
        // let result = create(&config, input).await;
        // assert!(result.is_ok());
    }
}
