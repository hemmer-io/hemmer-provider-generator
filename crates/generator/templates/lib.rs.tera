//! {{ service_name | capitalize }} Provider for Hemmer
//!
//! Auto-generated from {{ provider }} SDK version {{ sdk_version }}
//!
//! Protocol version: Uses hemmer-provider-sdk protocol version negotiation.
//! See [`PROTOCOL_VERSION`] for the current protocol version.

pub mod resources;

use hemmer_provider_sdk::{
    async_trait, serde_json, tonic,
    ProviderService, ProviderSchema, Schema, Block, Attribute, AttributeType, AttributeFlags,
    PlanResult, AttributeChange, ImportedResource, ProviderMetadata, ServerCapabilities,
    // Protocol versioning - re-export for visibility
    PROTOCOL_VERSION, MIN_PROTOCOL_VERSION, check_protocol_version,
};
use std::collections::HashMap;
{% if provider | has_config_crate %}
use std::sync::Arc;
use tokio::sync::RwLock;
{% endif %}
use thiserror::Error;
use tracing::{debug, error, info, warn};

// Re-export protocol version constants for consumers
pub use hemmer_provider_sdk::{PROTOCOL_VERSION as SDK_PROTOCOL_VERSION, MIN_PROTOCOL_VERSION as SDK_MIN_PROTOCOL_VERSION};

use hemmer_provider_sdk::ProviderError;

{% if provider == "Aws" %}
// AWS SDK error handling
use {{ provider | config_crate(service_name=service_name) }}::error::ProvideErrorMetadata;

/// Categorize AWS SDK error codes and convert to ProviderError
fn categorize_aws_error_code(code: Option<&str>, message: String) -> ProviderError {
    match code {
        // Not Found errors
        Some(c) if c.contains("NotFound") || c.contains("NoSuch") || c == "ResourceNotFoundException" => {
            ProviderError::NotFound(message)
        }
        // Already Exists errors
        Some(c) if c.contains("AlreadyExists") || c.contains("AlreadyOwned") || c == "EntityAlreadyExists" || c == "DuplicateRequest" => {
            ProviderError::AlreadyExists(message)
        }
        // Permission Denied errors
        Some(c) if c.contains("AccessDenied") || c.contains("Unauthorized") || c == "InvalidAccessKeyId" || c == "SignatureDoesNotMatch" || c == "ExpiredToken" || c == "InvalidToken" => {
            ProviderError::PermissionDenied(message)
        }
        // Invalid Argument errors
        Some(c) if c.contains("Invalid") || c.contains("Malformed") || c == "ValidationException" || c == "ValidationError" || c.contains("ParameterValue") => {
            ProviderError::Validation(message)
        }
        // Failed Precondition errors
        Some(c) if c.contains("NotEmpty") || c.contains("InUse") || c.contains("Conflict") || c == "OperationAborted" || c == "PreconditionFailed" || c == "ConditionalCheckFailedException" => {
            ProviderError::FailedPrecondition(message)
        }
        // Resource Exhausted errors
        Some(c) if c.contains("LimitExceeded") || c.contains("TooMany") || c == "SlowDown" || c == "Throttling" || c == "ThrottlingException" || c == "ProvisionedThroughputExceededException" || c == "RequestLimitExceeded" => {
            ProviderError::ResourceExhausted(message)
        }
        // Unavailable errors
        Some(c) if c == "ServiceUnavailable" || c == "InternalError" || c == "InternalFailure" || c.contains("ServiceException") => {
            ProviderError::Unavailable(message)
        }
        // Deadline Exceeded errors
        Some(c) if c == "RequestTimeout" || c == "RequestExpired" || c.contains("Timeout") => {
            ProviderError::DeadlineExceeded(message)
        }
        // Unimplemented errors
        Some(c) if c == "NotImplemented" || c == "UnsupportedOperation" => {
            ProviderError::Unimplemented(message)
        }
        // Unknown/fallback
        _ => ProviderError::Sdk(message),
    }
}

/// Convert AWS SDK error to ProviderError (which can be converted to tonic::Status)
fn sdk_error_to_provider_error<E, R>(error: &aws_smithy_runtime_api::client::result::SdkError<E, R>) -> ProviderError
where
    E: std::fmt::Debug + ProvideErrorMetadata,
{
    let message = format!("{:?}", error);

    match error {
        aws_smithy_runtime_api::client::result::SdkError::ServiceError(service_err) => {
            let code = service_err.err().code();
            debug!("AWS error code: {:?}", code);
            categorize_aws_error_code(code, message)
        }
        aws_smithy_runtime_api::client::result::SdkError::TimeoutError(_) => {
            ProviderError::DeadlineExceeded(message)
        }
        aws_smithy_runtime_api::client::result::SdkError::DispatchFailure(_) => {
            ProviderError::Unavailable(message)
        }
        aws_smithy_runtime_api::client::result::SdkError::ResponseError(_) => {
            ProviderError::Sdk(message)
        }
        aws_smithy_runtime_api::client::result::SdkError::ConstructionFailure(_) => {
            ProviderError::Validation(message)
        }
        _ => ProviderError::Sdk(message),
    }
}
{% else %}
/// Convert SDK error to ProviderError (which can be converted to tonic::Status)
fn sdk_error_to_provider_error<E: std::fmt::Debug>(error: &E) -> ProviderError {
    // For non-AWS providers, default to SDK error
    // Provider-specific error mapping can be added here
    ProviderError::Sdk(format!("{:?}", error))
}
{% endif %}

/// {{ service_name | capitalize }} Provider
pub struct {{ service_name | capitalize }}Provider {
{% if provider | has_config_crate %}
    /// SDK client (set during configure)
    client: Arc<RwLock<Option<{{ provider | client_type(service_name=service_name) }}>>>,
{% else %}
    _configured: bool,
{% endif %}
}

impl {{ service_name | capitalize }}Provider {
    /// Create a new provider instance (unconfigured)
    pub fn new() -> Self {
        Self {
{% if provider | has_config_crate %}
            client: Arc::new(RwLock::new(None)),
{% else %}
            _configured: false,
{% endif %}
        }
    }

{% if provider | has_config_crate %}
    /// Get the SDK client, returning an error if not configured
    async fn get_client(&self) -> std::result::Result<{{ provider | client_type(service_name=service_name) }}, tonic::Status> {
        let guard = self.client.read().await;
        guard.clone().ok_or_else(|| {
            tonic::Status::failed_precondition("Provider not configured. Call configure() first.")
        })
    }
{% endif %}

    /// Build the provider schema
    fn build_schema() -> ProviderSchema {
        let mut resources = HashMap::new();
{% for resource in resources %}

        // {{ resource.name | capitalize }} resource schema
        let mut {{ resource.name }}_attrs = HashMap::new();
{% for field in resource.fields %}
        {{ resource.name }}_attrs.insert(
            "{{ field.name }}".to_string(),
            Attribute::new(
                {{ field.field_type | sdk_attr_type }},
{% if field.required %}
                AttributeFlags::required(),
{% else %}
                AttributeFlags::optional(),
{% endif %}
            ){% if field.sensitive %}.sensitive(){% endif %}{% if field.description %}.with_description("{{ field.description }}"){% endif %}{% if field.immutable %}.with_force_new(){% endif %},
        );
{% endfor %}
{% for output in resource.outputs %}
        {{ resource.name }}_attrs.insert(
            "{{ output.name }}".to_string(),
            Attribute::new(
                {{ output.field_type | sdk_attr_type }},
                AttributeFlags::computed(),
            ){% if output.description %}.with_description("{{ output.description }}"){% endif %},
        );
{% endfor %}
        resources.insert(
            "{{ resource.name }}".to_string(),
            Schema {
                version: 1,
                block: Block {
                    attributes: {{ resource.name }}_attrs,
                    blocks: HashMap::new(),
                },
            },
        );
{% endfor %}

        // Provider config schema
        let mut config_attrs = HashMap::new();
{% for attr in config_attrs %}
        config_attrs.insert(
            "{{ attr.name }}".to_string(),
            Attribute::optional_string().with_description("{{ attr.description }}"),
        );
{% endfor %}

        ProviderSchema {
            provider: Schema {
                version: 1,
                block: Block {
                    attributes: config_attrs,
                    blocks: HashMap::new(),
                },
            },
            resources,
            data_sources: HashMap::new(),
        }
    }
}

impl Default for {{ service_name | capitalize }}Provider {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl ProviderService for {{ service_name | capitalize }}Provider {
    fn schema(&self) -> ProviderSchema {
        Self::build_schema()
    }

    async fn configure(
        &self,
        config: serde_json::Value,
    ) -> std::result::Result<Vec<tonic::Status>, tonic::Status> {
        info!("Configuring {{ service_name }} provider");
        debug!("Config: {:?}", config);

{% if provider == "Aws" %}
        // Load AWS config from environment, optionally using provided region/profile
        let mut config_loader = aws_config::from_env();

        if let Some(region) = config.get("region").and_then(|v| v.as_str()) {
            info!("Using region: {}", region);
            config_loader = config_loader.region(aws_config::Region::new(region.to_string()));
        }

        if let Some(profile) = config.get("profile").and_then(|v| v.as_str()) {
            info!("Using profile: {}", profile);
            config_loader = config_loader.profile_name(profile);
        }

        let sdk_config = config_loader.load().await;
        let client = {{ provider | client_type(service_name=service_name) }}::new(&sdk_config);

        // Store the client for later use
        let mut guard = self.client.write().await;
        *guard = Some(client);
        info!("{{ service_name | capitalize }} provider configured successfully");
{% endif %}

        Ok(vec![])
    }

    async fn plan(
        &self,
        resource_type: &str,
        prior_state: Option<serde_json::Value>,
        proposed_state: serde_json::Value,
        _config: serde_json::Value,
    ) -> std::result::Result<PlanResult, tonic::Status> {
        debug!("Planning {} resource", resource_type);

        // Compute diff between prior and proposed states
        let mut result = PlanResult::from_diff(prior_state.as_ref(), &proposed_state);

        // Check if any immutable fields changed (requires resource replacement)
        if let Some(ref prior) = prior_state {
            if self.has_immutable_field_changes(resource_type, prior, &proposed_state) {
                result.requires_replace = true;
            }
        }

        Ok(result)
    }

    /// Check if any immutable fields have changed between prior and proposed states
    fn has_immutable_field_changes(
        &self,
        resource_type: &str,
        prior: &serde_json::Value,
        proposed: &serde_json::Value,
    ) -> bool {
        // Get immutable fields for this resource type
        let immutable_fields: &[&str] = match resource_type {
{% for resource in resources %}
            "{{ resource.name }}" => &[
{% for field in resource.fields %}
{% if field.immutable %}
                "{{ field.name }}",
{% endif %}
{% endfor %}
            ],
{% endfor %}
            _ => &[],
        };

        // Check each immutable field for changes
        for field in immutable_fields {
            let prior_val = prior.get(*field);
            let proposed_val = proposed.get(*field);

            if prior_val != proposed_val {
                return true;
            }
        }

        false
    }

    async fn create(
        &self,
        resource_type: &str,
        planned_state: serde_json::Value,
        _config: serde_json::Value,
    ) -> std::result::Result<serde_json::Value, tonic::Status> {
        info!("Creating {} resource", resource_type);

{% if provider | has_config_crate %}
        let client = self.get_client().await?;
{% endif %}

        match resource_type {
{% for resource in resources %}
            "{{ resource.name }}" => {
{% if resource.operations.create %}
                debug!("Creating {{ resource.name }}: {:?}", planned_state);

                // Build the SDK request
                let mut request = client.{{ resource.operations.create.sdk_operation }}();

                // Set required fields from planned state
{% for field in resource.fields %}
{% if field.required %}
                if let Some(val) = planned_state.get("{{ field.name }}") {
{% if field.field_type == "String" %}
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
{% elif field.field_type == "Integer" %}
                    if let Some(n) = val.as_i64() {
                        request = request.{{ field.name }}(n as i32);
                    }
{% elif field.field_type == "Boolean" %}
                    if let Some(b) = val.as_bool() {
                        request = request.{{ field.name }}(b);
                    }
{% else %}
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
{% endif %}
                }
{% endif %}
{% endfor %}

                // Set optional fields
{% for field in resource.fields %}
{% if not field.required %}
                if let Some(val) = planned_state.get("{{ field.name }}") {
{% if field.field_type == "String" %}
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
{% elif field.field_type == "Integer" %}
                    if let Some(n) = val.as_i64() {
                        request = request.{{ field.name }}(n as i32);
                    }
{% elif field.field_type == "Boolean" %}
                    if let Some(b) = val.as_bool() {
                        request = request.{{ field.name }}(b);
                    }
{% else %}
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
{% endif %}
                }
{% endif %}
{% endfor %}

                // Execute the request
                match request.send().await {
                    Ok(response) => {
                        info!("Successfully created {{ resource.name }}");
                        debug!("Response: {:?}", response);

                        // Build the result state with computed outputs extracted from response
                        let mut result = planned_state.clone();
                        if let Some(obj) = result.as_object_mut() {
{% for output_field in resource.outputs %}
{% if output_field.response_accessor %}
{% if output_field.field_type == "String" %}
                            if let Some(val) = response.{{ output_field.response_accessor }}() {
                                obj.insert(
                                    "{{ output_field.name }}".to_string(),
                                    serde_json::Value::String(val.to_string()),
                                );
                            }
{% elif output_field.field_type == "Integer" %}
                            if let Some(val) = response.{{ output_field.response_accessor }}() {
                                obj.insert(
                                    "{{ output_field.name }}".to_string(),
                                    serde_json::Value::Number(serde_json::Number::from(*val)),
                                );
                            }
{% elif output_field.field_type == "Boolean" %}
                            if let Some(val) = response.{{ output_field.response_accessor }}() {
                                obj.insert(
                                    "{{ output_field.name }}".to_string(),
                                    serde_json::Value::Bool(*val),
                                );
                            }
{% else %}
                            if let Some(val) = response.{{ output_field.response_accessor }}() {
                                obj.insert(
                                    "{{ output_field.name }}".to_string(),
                                    serde_json::Value::String(format!("{:?}", val)),
                                );
                            }
{% endif %}
{% endif %}
{% endfor %}
                        }
                        Ok(result)
                    }
                    Err(e) => {
                        error!("Failed to create {{ resource.name }}: {:?}", e);
                        Err(sdk_error_to_provider_error(&e).into())
                    }
                }
{% else %}
                debug!("Creating {{ resource.name }}: {:?}", planned_state);
                Ok(planned_state)
{% endif %}
            }
{% endfor %}
            _ => {
                error!("Unknown resource type: {}", resource_type);
                Err(tonic::Status::not_found(format!(
                    "Unknown resource type: {}",
                    resource_type
                )))
            }
        }
    }

    async fn read(
        &self,
        resource_type: &str,
        current_state: serde_json::Value,
        _config: serde_json::Value,
    ) -> std::result::Result<serde_json::Value, tonic::Status> {
        debug!("Reading {} resource", resource_type);

{% if provider | has_config_crate %}
        let client = self.get_client().await?;
{% endif %}

        match resource_type {
{% for resource in resources %}
            "{{ resource.name }}" => {
{% if resource.operations.read %}
                debug!("Reading {{ resource.name }}: {:?}", current_state);

                // Build the SDK request
                let mut request = client.{{ resource.operations.read.sdk_operation }}();

                // Set identifier fields from current state
{% for field in resource.fields %}
{% if field.required and field.immutable %}
                if let Some(val) = current_state.get("{{ field.name }}") {
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
                }
{% endif %}
{% endfor %}

                match request.send().await {
                    Ok(response) => {
                        debug!("Read response: {:?}", response);
                        // TODO: Map response fields back to state
                        Ok(current_state)
                    }
                    Err(e) => {
                        warn!("Failed to read {{ resource.name }}: {:?}", e);
                        // Return current state on read failure (resource may not exist)
                        Ok(current_state)
                    }
                }
{% else %}
                Ok(current_state)
{% endif %}
            }
{% endfor %}
            _ => Err(tonic::Status::not_found(format!(
                "Unknown resource type: {}",
                resource_type
            ))),
        }
    }

    async fn update(
        &self,
        resource_type: &str,
        _prior_state: serde_json::Value,
        planned_state: serde_json::Value,
        _config: serde_json::Value,
    ) -> std::result::Result<serde_json::Value, tonic::Status> {
        info!("Updating {} resource", resource_type);

{% if provider | has_config_crate %}
        let client = self.get_client().await?;
{% endif %}

        match resource_type {
{% for resource in resources %}
            "{{ resource.name }}" => {
{% if resource.operations.update %}
                debug!("Updating {{ resource.name }}: {:?}", planned_state);

                // Build the SDK request
                let mut request = client.{{ resource.operations.update.sdk_operation }}();

                // Set identifier fields
{% for field in resource.fields %}
{% if field.required and field.immutable %}
                if let Some(val) = planned_state.get("{{ field.name }}") {
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
                }
{% endif %}
{% endfor %}

                // Set updatable fields
{% for field in resource.fields %}
{% if not field.immutable %}
                if let Some(val) = planned_state.get("{{ field.name }}") {
{% if field.field_type == "String" %}
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
{% elif field.field_type == "Integer" %}
                    if let Some(n) = val.as_i64() {
                        request = request.{{ field.name }}(n as i32);
                    }
{% elif field.field_type == "Boolean" %}
                    if let Some(b) = val.as_bool() {
                        request = request.{{ field.name }}(b);
                    }
{% else %}
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
{% endif %}
                }
{% endif %}
{% endfor %}

                match request.send().await {
                    Ok(response) => {
                        info!("Successfully updated {{ resource.name }}");
                        debug!("Response: {:?}", response);
                        Ok(planned_state)
                    }
                    Err(e) => {
                        error!("Failed to update {{ resource.name }}: {:?}", e);
                        Err(sdk_error_to_provider_error(&e).into())
                    }
                }
{% else %}
                Ok(planned_state)
{% endif %}
            }
{% endfor %}
            _ => Err(tonic::Status::not_found(format!(
                "Unknown resource type: {}",
                resource_type
            ))),
        }
    }

    async fn delete(
        &self,
        resource_type: &str,
        current_state: serde_json::Value,
        _config: serde_json::Value,
    ) -> std::result::Result<(), tonic::Status> {
        info!("Deleting {} resource", resource_type);

{% if provider | has_config_crate %}
        let client = self.get_client().await?;
{% endif %}

        match resource_type {
{% for resource in resources %}
            "{{ resource.name }}" => {
{% if resource.operations.delete %}
                debug!("Deleting {{ resource.name }}: {:?}", current_state);

                // Build the SDK request
                let mut request = client.{{ resource.operations.delete.sdk_operation }}();

                // Set identifier fields
{% for field in resource.fields %}
{% if field.required and field.immutable %}
                if let Some(val) = current_state.get("{{ field.name }}") {
                    if let Some(s) = val.as_str() {
                        request = request.{{ field.name }}(s);
                    }
                }
{% endif %}
{% endfor %}

                match request.send().await {
                    Ok(_) => {
                        info!("Successfully deleted {{ resource.name }}");
                        Ok(())
                    }
                    Err(e) => {
                        error!("Failed to delete {{ resource.name }}: {:?}", e);
                        Err(sdk_error_to_provider_error(&e).into())
                    }
                }
{% else %}
                debug!("Deleting {{ resource.name }}: {:?}", current_state);
                Ok(())
{% endif %}
            }
{% endfor %}
            _ => Err(tonic::Status::not_found(format!(
                "Unknown resource type: {}",
                resource_type
            ))),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_provider_creation() {
        let provider = {{ service_name | capitalize }}Provider::new();
        let schema = provider.schema();
        assert!(!schema.resources.is_empty());
    }

    #[test]
    fn test_schema_has_resources() {
        let provider = {{ service_name | capitalize }}Provider::new();
        let schema = provider.schema();
{% for resource in resources %}
        assert!(schema.resources.contains_key("{{ resource.name }}"));
{% endfor %}
    }
}
