//! {{ provider_name | capitalize }} Provider for Hemmer
//!
//! Auto-generated unified provider from {{ provider_name }} SDK version {{ sdk_version }}
//!
//! Protocol version: Uses hemmer-provider-sdk protocol version negotiation.
//! See [`PROTOCOL_VERSION`] for the current protocol version.
//!
//! This provider includes multiple services:
{% for service in services %}//! - {{ service.name }}
{% endfor %}

{% for service in services %}pub mod {{ service.name }};
{% endfor %}

use hemmer_provider_sdk::{
    Attribute, AttributeFlags, AttributeType, Block, PlanResult, ProviderSchema, ProviderService,
    Schema,
    // Protocol versioning - re-export for visibility
    PROTOCOL_VERSION, MIN_PROTOCOL_VERSION, check_protocol_version,
};
use std::collections::HashMap;
{% if provider | has_config_crate %}
use std::sync::Arc;
use tokio::sync::RwLock;
{% endif %}
use tracing::{debug, error, info, warn};

// Re-export protocol version constants for consumers
pub use hemmer_provider_sdk::{PROTOCOL_VERSION as SDK_PROTOCOL_VERSION, MIN_PROTOCOL_VERSION as SDK_MIN_PROTOCOL_VERSION};

/// Unified provider for {{ provider_name | capitalize }}
pub struct {{ provider_name | capitalize }}Provider {
{% if provider | has_config_crate %}
    /// SDK clients for each service (set during configure)
{% for service in services %}
    {{ service.name }}_client: Arc<RwLock<Option<{{ provider | client_type(service_name=service.name) }}>>>,
{% endfor %}
{% else %}
    config: HashMap<String, String>,
{% endif %}
}

impl {{ provider_name | capitalize }}Provider {
    /// Create a new provider instance
    pub fn new() -> Self {
        Self {
{% if provider | has_config_crate %}
{% for service in services %}
            {{ service.name }}_client: Arc::new(RwLock::new(None)),
{% endfor %}
{% else %}
            config: HashMap::new(),
{% endif %}
        }
    }

{% if provider | has_config_crate %}
{% for service in services %}
    /// Get the {{ service.name }} client, returning an error if not configured
    pub async fn get_{{ service.name }}_client(&self) -> Result<{{ provider | client_type(service_name=service.name) }}, String> {
        let guard = self.{{ service.name }}_client.read().await;
        guard.clone().ok_or_else(|| "Provider not configured. Call configure() first.".to_string())
    }
{% endfor %}
{% endif %}

    /// Build the provider schema
    fn build_schema() -> ProviderSchema {
        ProviderSchema {
            provider: Schema {
                version: 1,
                block: Block {
                    attributes: vec![
{% for attr in config_attrs %}
                        Attribute {
                            name: "{{ attr.name }}".to_string(),
                            attr_type: AttributeType::String,
                            flags: {% if attr.required %}AttributeFlags::REQUIRED{% else %}AttributeFlags::OPTIONAL{% endif %},
                            description: Some("{{ attr.description }}".to_string()),
                        },
{% endfor %}
                    ],
                    block_types: vec![],
                },
            },
            resources: Self::build_resource_schemas(),
            data_sources: HashMap::new(),
        }
    }

    /// Build resource schemas for all services
    fn build_resource_schemas() -> HashMap<String, Schema> {
        let mut resources = HashMap::new();
{% for service in services %}
{% for resource in service.resources %}

        // {{ service.name }}.{{ resource.name }}
        resources.insert(
            "{{ service.name }}_{{ resource.name }}".to_string(),
            Schema {
                version: 1,
                block: Block {
                    attributes: vec![
{% for field in resource.fields %}
                        Attribute {
                            name: "{{ field.name }}".to_string(),
                            attr_type: {{ field.field_type | sdk_attr_type }},
                            flags: {% if field.required %}AttributeFlags::REQUIRED{% else %}AttributeFlags::OPTIONAL{% endif %}{% if field.sensitive %} | AttributeFlags::SENSITIVE{% endif %}{% if field.immutable %} | AttributeFlags::FORCE_NEW{% endif %},
                            description: {% if field.description %}Some("{{ field.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
{% for output in resource.outputs %}
                        Attribute {
                            name: "{{ output.name }}".to_string(),
                            attr_type: {{ output.field_type | sdk_attr_type }},
                            flags: AttributeFlags::COMPUTED,
                            description: {% if output.description %}Some("{{ output.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
                    ],
                    block_types: vec![],
                },
            },
        );
{% endfor %}
{% endfor %}

        resources
    }
}

impl Default for {{ provider_name | capitalize }}Provider {
    fn default() -> Self {
        Self::new()
    }
}

impl ProviderService for {{ provider_name | capitalize }}Provider {
    fn schema(&self) -> ProviderSchema {
        Self::build_schema()
    }

    async fn configure(&self, config: serde_json::Value) -> Result<Vec<String>, String> {
        info!("Configuring {{ provider_name }} provider");
        debug!("Config: {:?}", config);

{% if provider == "Aws" %}
        // Load AWS config from environment, optionally using provided region/profile
        let mut config_loader = aws_config::from_env();

        if let Some(region) = config.get("region").and_then(|v| v.as_str()) {
            info!("Using region: {}", region);
            config_loader = config_loader.region(aws_config::Region::new(region.to_string()));
        }

        if let Some(profile) = config.get("profile").and_then(|v| v.as_str()) {
            info!("Using profile: {}", profile);
            config_loader = config_loader.profile_name(profile);
        }

        let sdk_config = config_loader.load().await;

        // Initialize clients for all services
{% for service in services %}
        {
            let client = {{ provider | client_type(service_name=service.name) }}::new(&sdk_config);
            let mut guard = self.{{ service.name }}_client.write().await;
            *guard = Some(client);
            info!("{{ service.name }} client configured");
        }
{% endfor %}
{% endif %}

        Ok(vec![])
    }

    fn plan(
        &self,
        resource_type: &str,
        prior_state: Option<serde_json::Value>,
        proposed: serde_json::Value,
    ) -> Result<PlanResult, String> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        // Compute diff between prior and proposed states
        let mut result = PlanResult::from_diff(prior_state.as_ref(), &proposed);

        // Check if any immutable fields changed (requires resource replacement)
        if let Some(ref prior) = prior_state {
            if self.has_immutable_field_changes(resource_type, prior, &proposed) {
                result.requires_replace = true;
            }
        }

        Ok(result)
    }

    /// Check if any immutable fields have changed between prior and proposed states
    fn has_immutable_field_changes(
        &self,
        resource_type: &str,
        prior: &serde_json::Value,
        proposed: &serde_json::Value,
    ) -> bool {
        // Get immutable fields for this resource type
        let immutable_fields: &[&str] = match resource_type {
{% for service in services %}
{% for resource in service.resources %}
            "{{ service.name }}_{{ resource.name }}" => &[
{% for field in resource.fields %}
{% if field.immutable %}
                "{{ field.name }}",
{% endif %}
{% endfor %}
            ],
{% endfor %}
{% endfor %}
            _ => &[],
        };

        // Check each immutable field for changes
        for field in immutable_fields {
            let prior_val = prior.get(*field);
            let proposed_val = proposed.get(*field);

            if prior_val != proposed_val {
                return true;
            }
        }

        false
    }

    async fn create(
        &self,
        resource_type: &str,
        planned: serde_json::Value,
    ) -> Result<serde_json::Value, String> {
        info!("Creating {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::create_resource(&resource_name, client, planned).await
{% else %}
                {{ service.name }}::create_resource(&resource_name, &self.config, planned).await
{% endif %}
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }

    async fn read(
        &self,
        resource_type: &str,
        current: serde_json::Value,
    ) -> Result<serde_json::Value, String> {
        debug!("Reading {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::read_resource(&resource_name, client, current).await
{% else %}
                {{ service.name }}::read_resource(&resource_name, &self.config, current).await
{% endif %}
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }

    async fn update(
        &self,
        resource_type: &str,
        _prior: serde_json::Value,
        planned: serde_json::Value,
    ) -> Result<serde_json::Value, String> {
        info!("Updating {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::update_resource(&resource_name, client, planned).await
{% else %}
                {{ service.name }}::update_resource(&resource_name, &self.config, planned).await
{% endif %}
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }

    async fn delete(
        &self,
        resource_type: &str,
        current: serde_json::Value,
    ) -> Result<(), String> {
        info!("Deleting {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::delete_resource(&resource_name, client, current).await
{% else %}
                {{ service.name }}::delete_resource(&resource_name, &self.config, current).await
{% endif %}
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }

    async fn import_resource(
        &self,
        resource_type: &str,
        id: &str,
    ) -> Result<Vec<ImportedResource>, ProviderError> {
        info!("Importing {} resource with id: {}", resource_type, id);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!(
                "Invalid resource type: {}",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await
                    .map_err(|e| ProviderError::Configuration(e))?;
                {{ service.name }}::import_resource(&resource_name, client, id).await
{% else %}
                {{ service.name }}::import_resource(&resource_name, &self.config, id).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_provider_creation() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
        assert!(!schema.resources.is_empty());
    }

    #[test]
    fn test_schema_has_resources() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
{% for service in services %}
{% for resource in service.resources %}
        assert!(
            schema.resources.contains_key("{{ service.name }}_{{ resource.name }}"),
            "Schema should contain {{ service.name }}_{{ resource.name }}"
        );
{% endfor %}
{% endfor %}
    }
}
