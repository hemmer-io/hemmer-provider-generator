//! {{ provider_name | capitalize }} Provider for Hemmer
//!
//! Auto-generated unified provider from {{ provider_name }} SDK version {{ sdk_version }}
//!
//! Protocol version: Uses hemmer-provider-sdk protocol version negotiation.
//! See [`PROTOCOL_VERSION`] for the current protocol version.
//!
//! This provider includes multiple services:
{% for service in services %}//! - {{ service.name }}
{% endfor %}

{% for service in services %}pub mod {{ service.name }};
{% endfor %}

use hemmer_provider_sdk::{
    Attribute, AttributeFlags, AttributeType, Block, BlockType, NestingMode, PlanResult, ProviderSchema, ProviderService,
    Schema, ProviderError, ImportedResource,
    schema::Diagnostic,
    // Protocol versioning - re-export for visibility
    PROTOCOL_VERSION, MIN_PROTOCOL_VERSION, check_protocol_version,
};
use std::collections::HashMap;
{% if provider | has_config_crate %}
use std::sync::Arc;
use tokio::sync::RwLock;
{% endif %}
use tracing::{debug, error, info, warn};

// Re-export protocol version constants for consumers
pub use hemmer_provider_sdk::{PROTOCOL_VERSION as SDK_PROTOCOL_VERSION, MIN_PROTOCOL_VERSION as SDK_MIN_PROTOCOL_VERSION};

/// Unified provider for {{ provider_name | capitalize }}
pub struct {{ provider_name | capitalize }}Provider {
{% if provider | has_config_crate %}
    /// SDK clients for each service (set during configure)
{% for service in services %}
    {{ service.name }}_client: Arc<RwLock<Option<{{ provider | client_type(service_name=service.name) }}>>>,
{% endfor %}
{% else %}
    config: HashMap<String, String>,
{% endif %}
}

impl {{ provider_name | capitalize }}Provider {
    /// Create a new provider instance
    pub fn new() -> Self {
        Self {
{% if provider | has_config_crate %}
{% for service in services %}
            {{ service.name }}_client: Arc::new(RwLock::new(None)),
{% endfor %}
{% else %}
            config: HashMap::new(),
{% endif %}
        }
    }

{% if provider | has_config_crate %}
{% for service in services %}
    /// Get the {{ service.name }} client, returning an error if not configured
    pub async fn get_{{ service.name }}_client(&self) -> Result<{{ provider | client_type(service_name=service.name) }}, ProviderError> {
        let guard = self.{{ service.name }}_client.read().await;
        guard.clone().ok_or_else(|| ProviderError::InvalidRequest("Provider not configured. Call configure() first.".to_string()))
    }
{% endfor %}
{% endif %}

    /// Build the provider schema
    fn build_schema() -> ProviderSchema {
        ProviderSchema {
            provider: Schema {
                version: 1,
                block: Block {
                    attributes: vec![
{% for attr in config_attrs %}
                        Attribute {
                            name: "{{ attr.name }}".to_string(),
                            attr_type: AttributeType::String,
                            flags: {% if attr.required %}AttributeFlags::REQUIRED{% else %}AttributeFlags::OPTIONAL{% endif %},
                            description: Some("{{ attr.description }}".to_string()),
                        },
{% endfor %}
                    ],
                    block_types: vec![],
                },
            },
            resources: Self::build_resource_schemas(),
            data_sources: Self::build_data_source_schemas(),
        }
    }

    /// Build resource schemas for all services
    fn build_resource_schemas() -> HashMap<String, Schema> {
        let mut resources = HashMap::new();
{% for service in services %}
{% for resource in service.resources %}

        // {{ service.name }}.{{ resource.name }}
        resources.insert(
            "{{ service.name }}_{{ resource.name }}".to_string(),
            Schema {
                version: 1,
                block: Block {
                    attributes: vec![
{% for field in resource.fields %}
                        Attribute {
                            name: "{{ field.name }}".to_string(),
                            attr_type: {{ field.field_type | sdk_attr_type }},
                            flags: {% if field.required %}AttributeFlags::REQUIRED{% else %}AttributeFlags::OPTIONAL{% endif %}{% if field.sensitive %} | AttributeFlags::SENSITIVE{% endif %}{% if field.immutable %} | AttributeFlags::FORCE_NEW{% endif %},
                            description: {% if field.description %}Some("{{ field.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
{% for output in resource.outputs %}
                        Attribute {
                            name: "{{ output.name }}".to_string(),
                            attr_type: {{ output.field_type | sdk_attr_type }},
                            flags: AttributeFlags::COMPUTED,
                            description: {% if output.description %}Some("{{ output.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
                    ],
                    block_types: vec![
{% for block in resource.blocks %}
                        // {{ block.name }} block
                        BlockType {
                            nesting_mode: {{ block.nesting_mode | nesting_mode }},
                            block: Block {
                                attributes: vec![
{% for attr in block.attributes %}
                                    Attribute {
                                        name: "{{ attr.name }}".to_string(),
                                        attr_type: {{ attr.field_type | sdk_attr_type }},
                                        flags: {% if attr.required %}AttributeFlags::REQUIRED{% else %}AttributeFlags::OPTIONAL{% endif %}{% if attr.sensitive %} | AttributeFlags::SENSITIVE{% endif %},
                                        description: {% if attr.description %}Some("{{ attr.description }}".to_string()){% else %}None{% endif %},
                                    },
{% endfor %}
                                ],
                                block_types: vec![
                                    // TODO: Support recursive nested blocks (currently limited to 1 level)
{% for nested_block in block.blocks %}
{% endfor %}
                                ],
                            },
                            min_items: {{ block.min_items }},
                            max_items: {{ block.max_items }},
                        },
{% endfor %}
                    ],
                },
            },
        );
{% endfor %}
{% endfor %}

        resources
    }

    /// Build data source schemas for all services
    fn build_data_source_schemas() -> HashMap<String, Schema> {
        let mut data_sources = HashMap::new();
{% for service in services %}
{% for ds in service.data_sources %}

        // {{ service.name }}.{{ ds.name }}
        data_sources.insert(
            "{{ service.name }}_{{ ds.name }}".to_string(),
            Schema {
                version: 1,
                block: Block {
                    attributes: vec![
{% for arg in ds.arguments %}
                        Attribute {
                            name: "{{ arg.name }}".to_string(),
                            attr_type: {{ arg.field_type | sdk_attr_type }},
                            flags: {% if arg.required %}AttributeFlags::REQUIRED{% else %}AttributeFlags::OPTIONAL{% endif %},
                            description: {% if arg.description %}Some("{{ arg.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
{% for attr in ds.attributes %}
                        Attribute {
                            name: "{{ attr.name }}".to_string(),
                            attr_type: {{ attr.field_type | sdk_attr_type }},
                            flags: AttributeFlags::COMPUTED,
                            description: {% if attr.description %}Some("{{ attr.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
                    ],
                    block_types: vec![],
                },
            },
        );
{% endfor %}
{% endfor %}

        data_sources
    }
}

impl Default for {{ provider_name | capitalize }}Provider {
    fn default() -> Self {
        Self::new()
    }
}

impl ProviderService for {{ provider_name | capitalize }}Provider {
    fn schema(&self) -> ProviderSchema {
        Self::build_schema()
    }

    async fn configure(&self, config: serde_json::Value) -> Result<Vec<Diagnostic>, ProviderError> {
        info!("Configuring {{ provider_name }} provider");
        debug!("Config: {:?}", config);

        // Initialize SDK config using provider-specific pattern
        let mut {{ sdk_config.config_codegen.config_var_name }} = {{ sdk_config.config_codegen.init_snippet }};

        // Apply optional configuration attributes
{% for attr in sdk_config.config_attrs %}
{% if attr.setter_snippet %}
        if let Some(val) = config.get("{{ attr.name }}").and_then(|v| v.{{ attr.value_extractor | default(value="as_str()") }}) {
            info!("Using {{ attr.name }}: {}", val);
            {{ attr.setter_snippet | replace(from="{value}", to="val") }};
        }
{% endif %}
{% endfor %}

        // Load the configuration
        let {{ sdk_config.config_codegen.loaded_config_var_name }} = {{ sdk_config.config_codegen.load_snippet }};

        // Initialize clients for all services
{% for service in services %}
        {
            let client = {{ sdk_config.config_codegen.client_from_config | replace(from="{client_type}", to=provider | client_type(service_name=service.name)) | replace(from="{config}", to=sdk_config.config_codegen.loaded_config_var_name) }};
            let mut guard = self.{{ service.name }}_client.write().await;
            *guard = Some(client);
            info!("{{ service.name }} client configured");
        }
{% endfor %}

        Ok(vec![])
    }

    async fn plan(
        &self,
        resource_type: &str,
        prior_state: Option<serde_json::Value>,
        proposed_state: serde_json::Value,
        config: serde_json::Value,
    ) -> Result<PlanResult, ProviderError> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        // Compute diff between prior and proposed states
        let mut result = PlanResult::from_diff(prior_state.as_ref(), &proposed_state);

        // Check if any immutable fields changed (requires resource replacement)
        if let Some(ref prior) = prior_state {
            if self.has_immutable_field_changes(resource_type, prior, &proposed_state) {
                result.requires_replace = true;
            }
        }

        Ok(result)
    }

    /// Check if any immutable fields have changed between prior and proposed states
    fn has_immutable_field_changes(
        &self,
        resource_type: &str,
        prior: &serde_json::Value,
        proposed: &serde_json::Value,
    ) -> bool {
        // Get immutable fields for this resource type
        let immutable_fields: &[&str] = match resource_type {
{% for service in services %}
{% for resource in service.resources %}
            "{{ service.name }}_{{ resource.name }}" => &[
{% for field in resource.fields %}
{% if field.immutable %}
                "{{ field.name }}",
{% endif %}
{% endfor %}
            ],
{% endfor %}
{% endfor %}
            _ => &[],
        };

        // Check each immutable field for changes
        for field in immutable_fields {
            let prior_val = prior.get(*field);
            let proposed_val = proposed.get(*field);

            if prior_val != proposed_val {
                return true;
            }
        }

        false
    }

    async fn create(
        &self,
        resource_type: &str,
        planned_state: serde_json::Value,
    ) -> Result<serde_json::Value, ProviderError> {
        info!("Creating {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::create_resource(&resource_name, client, planned_state).await
{% else %}
                {{ service.name }}::create_resource(&resource_name, &self.config, planned_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn read(
        &self,
        resource_type: &str,
        current_state: serde_json::Value,
    ) -> Result<serde_json::Value, ProviderError> {
        debug!("Reading {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::read_resource(&resource_name, client, current_state).await
{% else %}
                {{ service.name }}::read_resource(&resource_name, &self.config, current_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn update(
        &self,
        resource_type: &str,
        prior_state: serde_json::Value,
        planned_state: serde_json::Value,
    ) -> Result<serde_json::Value, ProviderError> {
        info!("Updating {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::update_resource(&resource_name, client, planned_state).await
{% else %}
                {{ service.name }}::update_resource(&resource_name, &self.config, planned_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn delete(
        &self,
        resource_type: &str,
        current_state: serde_json::Value,
    ) -> Result<(), ProviderError> {
        info!("Deleting {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::delete_resource(&resource_name, client, current_state).await
{% else %}
                {{ service.name }}::delete_resource(&resource_name, &self.config, current_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn import_resource(
        &self,
        resource_type: &str,
        id: &str,
    ) -> Result<Vec<ImportedResource>, ProviderError> {
        info!("Importing {} resource with id: {}", resource_type, id);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!(
                "Invalid resource type: {}",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::import_resource(&resource_name, client, id).await
{% else %}
                {{ service.name }}::import_resource(&resource_name, &self.config, id).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }

    async fn read_data_source(
        &self,
        data_source_type: &str,
        config: serde_json::Value,
    ) -> Result<serde_json::Value, ProviderError> {
        info!("Reading {} data source", data_source_type);

        // Parse data source type: service_datasource format
        let parts: Vec<&str> = data_source_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!(
                "Invalid data source type: {}",
                data_source_type
            )));
        }

        let service_name = parts[0];
        let ds_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::read_data_source(&ds_name, client, config).await
{% else %}
                {{ service.name }}::read_data_source(&ds_name, &self.config, config).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_provider_creation() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
        assert!(!schema.resources.is_empty());
    }

    #[test]
    fn test_schema_has_resources() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
{% for service in services %}
{% for resource in service.resources %}
        assert!(
            schema.resources.contains_key("{{ service.name }}_{{ resource.name }}"),
            "Schema should contain {{ service.name }}_{{ resource.name }}"
        );
{% endfor %}
{% endfor %}
    }
}
