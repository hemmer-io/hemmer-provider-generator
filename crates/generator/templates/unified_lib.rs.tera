//! {{ provider_name | capitalize }} Provider for Hemmer
//!
//! Auto-generated unified provider from {{ provider_name }} SDK version {{ sdk_version }}
//!
//! This provider includes multiple services:
{% for service in services %}//! - {{ service.name }}
{% endfor %}

{% for service in services %}pub mod {{ service.name }};
{% endfor %}

use async_trait::async_trait;
use hemmer_core::Result;
use hemmer_provider::{ProviderConfig, ProviderExecutor, ResourceInput, ResourceOutput, ResourcePlan};
use thiserror::Error;

/// Provider error types
#[derive(Error, Debug)]
pub enum ProviderError {
    #[error("Resource not found: {0}")]
    NotFound(String),

    #[error("SDK error: {0}")]
    SdkError(String),

    #[error("Validation error: {0}")]
    ValidationError(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

/// Result type for provider operations
pub type Result<T> = std::result::Result<T, ProviderError>;

/// Unified provider client for {{ provider_name | capitalize }}
pub struct {{ provider_name | capitalize }}Provider {
{% if provider == "Aws" %}{% for service in services %}    {{ service.name }}_client: aws_sdk_{{ service.name }}::Client,
{% endfor %}    /// Tokio runtime for async operations
    /// Each provider instance owns its own runtime to ensure async operations
    /// work correctly when loaded as a dynamic library (cdylib)
    runtime: tokio::runtime::Runtime,
{% elif provider == "Gcp" %}    // GCP clients
{% for service in services %}    // {{ service.name }}_client: google_{{ service.name }}::Client,
{% endfor %}    runtime: tokio::runtime::Runtime,
{% elif provider == "Azure" %}    // Azure clients
{% for service in services %}    // {{ service.name }}_client: azure_{{ service.name }}::Client,
{% endfor %}    runtime: tokio::runtime::Runtime,
{% elif provider == "Kubernetes" %}    kube_client: kube::Client,
    runtime: tokio::runtime::Runtime,
{% endif %}
}

impl {{ provider_name | capitalize }}Provider {
    /// Create a new unified provider instance
    pub fn new() -> Result<Self> {
        // Create Tokio runtime for async operations
        // This ensures async AWS SDK calls work when the provider is loaded as a dynamic library
        let runtime = tokio::runtime::Runtime::new()
            .map_err(|e| ProviderError::SdkError(format!("Failed to create Tokio runtime: {}", e)))?;

{% if provider == "Aws" %}        // Load AWS config and initialize clients using the runtime
        let (config{% for service in services %}, {{ service.name }}_client{% endfor %}) = runtime.block_on(async {
            let config = aws_config::load_from_env().await;
{% for service in services %}            let {{ service.name }}_client = aws_sdk_{{ service.name }}::Client::new(&config);
{% endfor %}            (config{% for service in services %}, {{ service.name }}_client{% endfor %})
        });

{% elif provider == "Kubernetes" %}        // Initialize Kubernetes client using the runtime
        let kube_client = runtime.block_on(async {
            kube::Client::try_default()
                .await
                .map_err(|e| ProviderError::SdkError(format!("Failed to create kube client: {}", e)))
        })?;

{% endif %}        Ok(Self {
{% if provider == "Aws" %}{% for service in services %}            {{ service.name }}_client,
{% endfor %}            runtime,
{% elif provider == "Kubernetes" %}            kube_client,
            runtime,
{% endif %}
        })
    }

{% for service in services %}    /// Get {{ service.name }} service handler
    pub fn {{ service.name }}(&self) -> {{ service.name }}::{{ service.name | capitalize }}Service<'_> {
        {{ service.name }}::{{ service.name | capitalize }}Service::new(self)
    }
{% endfor %}

    /// Get reference to the Tokio runtime for executing async operations
    pub(crate) fn runtime(&self) -> &tokio::runtime::Runtime {
        &self.runtime
    }
}

/// Implement ProviderExecutor trait for Hemmer integration
#[async_trait]
impl ProviderExecutor for {{ provider_name | capitalize }}Provider {
    /// Configure the provider with authentication and settings
    async fn configure(&mut self, config: ProviderConfig) -> Result<()> {
        // Configuration is already handled in new()
        // Additional runtime configuration can be added here
        Ok(())
    }

    /// Plan changes to a resource (diff current vs desired state)
    async fn plan(
        &self,
        resource_type: &str,
        current_state: Option<&ResourceOutput>,
        desired_input: &ResourceInput,
    ) -> Result<ResourcePlan> {
        // Dispatch to appropriate service based on resource_type
        // Format: "service_name.resource_name" (e.g., "s3.bucket")
        let parts: Vec<&str> = resource_type.split('.').collect();
        if parts.len() != 2 {
            return Err(hemmer_core::HemmerError::Provider(format!(
                "Invalid resource type format: {}. Expected 'service.resource'",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1];

        match service_name {
{% for service in services %}            "{{ service.name }}" => {
                self.{{ service.name }}().plan_resource(resource_name, current_state, desired_input).await
            }
{% endfor %}            _ => Err(hemmer_core::HemmerError::Provider(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }

    /// Create a new resource
    async fn create(&self, resource_type: &str, input: ResourceInput) -> Result<ResourceOutput> {
        let parts: Vec<&str> = resource_type.split('.').collect();
        if parts.len() != 2 {
            return Err(hemmer_core::HemmerError::Provider(format!(
                "Invalid resource type format: {}. Expected 'service.resource'",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1];

        match service_name {
{% for service in services %}            "{{ service.name }}" => {
                self.{{ service.name }}().create_resource(resource_name, input).await
            }
{% endfor %}            _ => Err(hemmer_core::HemmerError::Provider(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }

    /// Read/refresh resource state
    async fn read(&self, resource_type: &str, id: &str) -> Result<ResourceOutput> {
        let parts: Vec<&str> = resource_type.split('.').collect();
        if parts.len() != 2 {
            return Err(hemmer_core::HemmerError::Provider(format!(
                "Invalid resource type format: {}. Expected 'service.resource'",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1];

        match service_name {
{% for service in services %}            "{{ service.name }}" => {
                self.{{ service.name }}().read_resource(resource_name, id).await
            }
{% endfor %}            _ => Err(hemmer_core::HemmerError::Provider(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }

    /// Update an existing resource
    async fn update(
        &self,
        resource_type: &str,
        id: &str,
        input: ResourceInput,
    ) -> Result<ResourceOutput> {
        let parts: Vec<&str> = resource_type.split('.').collect();
        if parts.len() != 2 {
            return Err(hemmer_core::HemmerError::Provider(format!(
                "Invalid resource type format: {}. Expected 'service.resource'",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1];

        match service_name {
{% for service in services %}            "{{ service.name }}" => {
                self.{{ service.name }}().update_resource(resource_name, id, input).await
            }
{% endfor %}            _ => Err(hemmer_core::HemmerError::Provider(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }

    /// Delete a resource
    async fn delete(&self, resource_type: &str, id: &str) -> Result<()> {
        let parts: Vec<&str> = resource_type.split('.').collect();
        if parts.len() != 2 {
            return Err(hemmer_core::HemmerError::Provider(format!(
                "Invalid resource type format: {}. Expected 'service.resource'",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1];

        match service_name {
{% for service in services %}            "{{ service.name }}" => {
                self.{{ service.name }}().delete_resource(resource_name, id).await
            }
{% endfor %}            _ => Err(hemmer_core::HemmerError::Provider(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }
}

/// Factory function to create a provider instance
///
/// This is the entry point called by Hemmer when loading the provider as a dynamic library.
#[no_mangle]
pub extern "C" fn create_provider() -> *mut dyn ProviderExecutor {
    match {{ provider_name | capitalize }}Provider::new() {
        Ok(provider) => Box::into_raw(Box::new(provider)) as *mut dyn ProviderExecutor,
        Err(_) => std::ptr::null_mut(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_provider_creation() {
        // Provider creation test
        // Note: This will fail without proper credentials
        // let provider = {{ provider_name | capitalize }}Provider::new();
        // assert!(provider.is_ok());
    }
}
