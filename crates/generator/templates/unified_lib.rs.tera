//! {{ provider_name | capitalize }} Provider for Hemmer
//!
//! Auto-generated unified provider from {{ provider_name }} SDK version {{ sdk_version }}
//!
//! Protocol version: Uses hemmer-provider-sdk protocol version negotiation.
//! See [`PROTOCOL_VERSION`] for the current protocol version.
//!
//! This provider includes multiple services:
{% for service in services %}//! - {{ service.name }}
{% endfor %}

{% for service in services %}pub mod {{ service.name }};
{% endfor %}

use hemmer_provider_sdk::{
    Attribute, AttributeFlags, AttributeType, Block, PlanResult, ProviderSchema, ProviderService,
    Schema,
    // Protocol versioning - re-export for visibility
    PROTOCOL_VERSION, MIN_PROTOCOL_VERSION, check_protocol_version,
};
use std::collections::HashMap;

// Re-export protocol version constants for consumers
pub use hemmer_provider_sdk::{PROTOCOL_VERSION as SDK_PROTOCOL_VERSION, MIN_PROTOCOL_VERSION as SDK_MIN_PROTOCOL_VERSION};

/// Unified provider for {{ provider_name | capitalize }}
pub struct {{ provider_name | capitalize }}Provider {
    config: HashMap<String, String>,
}

impl {{ provider_name | capitalize }}Provider {
    /// Create a new provider instance
    pub fn new() -> Self {
        Self {
            config: HashMap::new(),
        }
    }

    /// Build the provider schema
    fn build_schema() -> ProviderSchema {
        ProviderSchema {
            provider: Schema {
                version: 1,
                block: Block {
                    attributes: vec![
{% if provider == "Aws" %}
                        Attribute {
                            name: "region".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("AWS region to use".to_string()),
                        },
                        Attribute {
                            name: "profile".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("AWS profile to use".to_string()),
                        },
{% elif provider == "Gcp" %}
                        Attribute {
                            name: "project".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("GCP project ID".to_string()),
                        },
                        Attribute {
                            name: "region".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("GCP region to use".to_string()),
                        },
{% elif provider == "Azure" %}
                        Attribute {
                            name: "subscription_id".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("Azure subscription ID".to_string()),
                        },
                        Attribute {
                            name: "tenant_id".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("Azure tenant ID".to_string()),
                        },
{% elif provider == "Kubernetes" %}
                        Attribute {
                            name: "kubeconfig".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("Path to kubeconfig file".to_string()),
                        },
                        Attribute {
                            name: "context".to_string(),
                            attr_type: AttributeType::String,
                            flags: AttributeFlags::OPTIONAL,
                            description: Some("Kubernetes context to use".to_string()),
                        },
{% endif %}
                    ],
                    block_types: vec![],
                },
            },
            resources: Self::build_resource_schemas(),
            data_sources: HashMap::new(),
        }
    }

    /// Build resource schemas for all services
    fn build_resource_schemas() -> HashMap<String, Schema> {
        let mut resources = HashMap::new();
{% for service in services %}
{% for resource in service.resources %}

        // {{ service.name }}.{{ resource.name }}
        resources.insert(
            "{{ service.name }}_{{ resource.name }}".to_string(),
            Schema {
                version: 1,
                block: Block {
                    attributes: vec![
{% for field in resource.fields %}
                        Attribute {
                            name: "{{ field.name }}".to_string(),
                            attr_type: AttributeType::{{ field.field_type | sdk_attr_type }},
                            flags: {% if field.required %}AttributeFlags::REQUIRED{% else %}AttributeFlags::OPTIONAL{% endif %}{% if field.sensitive %} | AttributeFlags::SENSITIVE{% endif %}{% if field.immutable %} | AttributeFlags::FORCE_NEW{% endif %},
                            description: {% if field.description %}Some("{{ field.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
{% for output in resource.outputs %}
                        Attribute {
                            name: "{{ output.name }}".to_string(),
                            attr_type: AttributeType::{{ output.field_type | sdk_attr_type }},
                            flags: AttributeFlags::COMPUTED,
                            description: {% if output.description %}Some("{{ output.description }}".to_string()){% else %}None{% endif %},
                        },
{% endfor %}
                    ],
                    block_types: vec![],
                },
            },
        );
{% endfor %}
{% endfor %}

        resources
    }
}

impl Default for {{ provider_name | capitalize }}Provider {
    fn default() -> Self {
        Self::new()
    }
}

impl ProviderService for {{ provider_name | capitalize }}Provider {
    fn schema(&self) -> ProviderSchema {
        Self::build_schema()
    }

    fn configure(&mut self, config: HashMap<String, serde_json::Value>) -> Result<(), String> {
        for (key, value) in config {
            if let serde_json::Value::String(s) = value {
                self.config.insert(key, s);
            }
        }
        Ok(())
    }

    fn plan(
        &self,
        resource_type: &str,
        _prior_state: Option<serde_json::Value>,
        proposed: serde_json::Value,
    ) -> Result<PlanResult, String> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        // Return the proposed state as the planned state
        Ok(PlanResult {
            planned_state: proposed,
            requires_replace: vec![],
        })
    }

    async fn create(
        &self,
        resource_type: &str,
        planned: serde_json::Value,
    ) -> Result<serde_json::Value, String> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
                {{ service.name }}::create_resource(&resource_name, &self.config, planned).await
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }

    async fn read(
        &self,
        resource_type: &str,
        current: serde_json::Value,
    ) -> Result<serde_json::Value, String> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
                {{ service.name }}::read_resource(&resource_name, &self.config, current).await
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }

    async fn update(
        &self,
        resource_type: &str,
        _prior: serde_json::Value,
        planned: serde_json::Value,
    ) -> Result<serde_json::Value, String> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
                {{ service.name }}::update_resource(&resource_name, &self.config, planned).await
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }

    async fn delete(
        &self,
        resource_type: &str,
        current: serde_json::Value,
    ) -> Result<(), String> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(format!("Invalid resource type: {}", resource_type));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
                {{ service.name }}::delete_resource(&resource_name, &self.config, current).await
            }
{% endfor %}
            _ => Err(format!("Unknown service: {}", service_name)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_provider_creation() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
        assert!(!schema.resources.is_empty());
    }

    #[test]
    fn test_schema_has_resources() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
{% for service in services %}
{% for resource in service.resources %}
        assert!(
            schema.resources.contains_key("{{ service.name }}_{{ resource.name }}"),
            "Schema should contain {{ service.name }}_{{ resource.name }}"
        );
{% endfor %}
{% endfor %}
    }
}
