//! {{ provider_name | capitalize }} Provider for Hemmer
//!
//! Auto-generated unified provider from {{ provider_name }} SDK version {{ sdk_version }}
//!
//! Protocol version: Uses hemmer-provider-sdk protocol version negotiation.
//! See [`PROTOCOL_VERSION`] for the current protocol version.
//!
//! This provider includes multiple services:
{% for service in services %}//! - {{ service.name }}
{% endfor %}

{% for service in services %}pub mod {{ service.name }};
{% endfor %}

use hemmer_provider_sdk::{
    async_trait,
    PlanResult, ProviderSchema, ProviderService, ProviderError, ImportedResource,
    schema::{Attribute, AttributeFlags, AttributeType, Block, BlockType, NestingMode, Schema, Diagnostic},
    // Protocol versioning - re-export for visibility
    PROTOCOL_VERSION, MIN_PROTOCOL_VERSION, check_protocol_version,
};
use std::collections::HashMap;
{% if provider | has_config_crate %}
use std::sync::Arc;
use tokio::sync::RwLock;
{% endif %}
use tracing::{debug, error, info, warn};

// Re-export protocol version constants for consumers
pub use hemmer_provider_sdk::{PROTOCOL_VERSION as SDK_PROTOCOL_VERSION, MIN_PROTOCOL_VERSION as SDK_MIN_PROTOCOL_VERSION};

// Type alias for convenience
pub type Result<T> = std::result::Result<T, ProviderError>;

/// Unified provider for {{ provider_name | capitalize }}
pub struct {{ provider_name | capitalize }}Provider {
{% if provider | has_config_crate %}
    /// SDK clients for each service (set during configure)
{% for service in services %}
    {{ service.name }}_client: Arc<RwLock<Option<{{ provider | client_type(service_name=service.name) }}>>>,
{% endfor %}
{% else %}
    config: HashMap<String, String>,
{% endif %}
}

impl {{ provider_name | capitalize }}Provider {
    /// Create a new provider instance
    pub fn new() -> Self {
        Self {
{% if provider | has_config_crate %}
{% for service in services %}
            {{ service.name }}_client: Arc::new(RwLock::new(None)),
{% endfor %}
{% else %}
            config: HashMap::new(),
{% endif %}
        }
    }

{% if provider | has_config_crate %}
{% for service in services %}
    /// Get the {{ service.name }} client, returning an error if not configured
    pub async fn get_{{ service.name }}_client(&self) -> Result<{{ provider | client_type(service_name=service.name) }}> {
        let guard = self.{{ service.name }}_client.read().await;
        guard.clone().ok_or_else(|| ProviderError::InvalidRequest("Provider not configured. Call configure() first.".to_string()))
    }
{% endfor %}
{% endif %}

    /// Build the provider schema
    fn build_schema() -> ProviderSchema {
        // Provider config attributes
        let mut config_attrs = HashMap::new();
{% for attr in config_attrs %}
        config_attrs.insert(
            "{{ attr.name }}".to_string(),
            Attribute::new(
                AttributeType::String,
{% if attr.required %}
                AttributeFlags::required(),
{% else %}
                AttributeFlags::optional(),
{% endif %}
            ).with_description("{{ attr.description }}"),
        );
{% endfor %}

        ProviderSchema {
            provider: Schema {
                version: 1,
                block: Block {
                    attributes: config_attrs,
                    blocks: HashMap::new(),
                    description: Some("Provider configuration".to_string()),
                },
            },
            resources: Self::build_resource_schemas(),
            data_sources: Self::build_data_source_schemas(),
        }
    }

    /// Build resource schemas for all services
    fn build_resource_schemas() -> HashMap<String, Schema> {
        let mut resources = HashMap::new();
{% for service in services %}
{% for resource in service.resources %}

        // {{ service.name }}.{{ resource.name }} resource schema
        let mut {{ service.name }}_{{ resource.name }}_attrs = HashMap::new();
{% for field in resource.fields %}
        {{ service.name }}_{{ resource.name }}_attrs.insert(
            "{{ field.name }}".to_string(),
            Attribute::new(
                {{ field.field_type | sdk_attr_type }},
{% if field.required %}
                AttributeFlags::required(),
{% else %}
                AttributeFlags::optional(),
{% endif %}
            ){% if field.sensitive %}.sensitive(){% endif %}{% if field.description %}.with_description("{{ field.description }}"){% endif %}{% if field.immutable %}.with_force_new(){% endif %},
        );
{% endfor %}
{% for output in resource.outputs %}
        {{ service.name }}_{{ resource.name }}_attrs.insert(
            "{{ output.name }}".to_string(),
            Attribute::new(
                {{ output.field_type | sdk_attr_type }},
                AttributeFlags::computed(),
            ){% if output.description %}.with_description("{{ output.description }}"){% endif %},
        );
{% endfor %}

        // {{ service.name }}.{{ resource.name }} nested blocks
        let mut {{ service.name }}_{{ resource.name }}_blocks = HashMap::new();
{% for block in resource.blocks %}
        // {{ block.name }} block
        {
            let mut {{ service.name }}_{{ resource.name }}_{{ block.name }}_attrs = HashMap::new();
{% for attr in block.attributes %}
            {{ service.name }}_{{ resource.name }}_{{ block.name }}_attrs.insert(
                "{{ attr.name }}".to_string(),
                Attribute::new(
                    {{ attr.field_type | sdk_attr_type }},
{% if attr.required %}
                    AttributeFlags::required(),
{% else %}
                    AttributeFlags::optional(),
{% endif %}
                ){% if attr.sensitive %}.sensitive(){% endif %}{% if attr.description %}.with_description("{{ attr.description }}"){% endif %},
            );
{% endfor %}

            let mut {{ service.name }}_{{ resource.name }}_{{ block.name }}_blocks = HashMap::new();
            // TODO: Support recursive nested blocks (currently limited to 1 level)
{% for nested_block in block.blocks %}
{% endfor %}

            {{ service.name }}_{{ resource.name }}_blocks.insert(
                "{{ block.name }}".to_string(),
                BlockType {
                    nesting_mode: {{ block.nesting_mode | nesting_mode }},
                    block: Block {
                        attributes: {{ service.name }}_{{ resource.name }}_{{ block.name }}_attrs,
                        blocks: {{ service.name }}_{{ resource.name }}_{{ block.name }}_blocks,
                        description: {% if block.description %}Some("{{ block.description }}".to_string()){% else %}None{% endif %},
                    },
                    min_items: {{ block.min_items }},
                    max_items: {{ block.max_items }},
                },
            );
        }
{% endfor %}

        resources.insert(
            "{{ service.name }}_{{ resource.name }}".to_string(),
            Schema {
                version: 1,
                block: Block {
                    attributes: {{ service.name }}_{{ resource.name }}_attrs,
                    blocks: {{ service.name }}_{{ resource.name }}_blocks,
                    description: {% if resource.description %}Some("{{ resource.description }}".to_string()){% else %}None{% endif %},
                },
            },
        );
{% endfor %}
{% endfor %}

        resources
    }

    /// Build data source schemas for all services
    fn build_data_source_schemas() -> HashMap<String, Schema> {
        let mut data_sources = HashMap::new();
{% for service in services %}
{% for ds in service.data_sources %}

        // {{ service.name }}.{{ ds.name }} data source schema
        let mut {{ service.name }}_{{ ds.name }}_attrs = HashMap::new();
{% for arg in ds.arguments %}
        {{ service.name }}_{{ ds.name }}_attrs.insert(
            "{{ arg.name }}".to_string(),
            Attribute::new(
                {{ arg.field_type | sdk_attr_type }},
{% if arg.required %}
                AttributeFlags::required(),
{% else %}
                AttributeFlags::optional(),
{% endif %}
            ){% if arg.description %}.with_description("{{ arg.description }}"){% endif %},
        );
{% endfor %}
{% for attr in ds.attributes %}
        {{ service.name }}_{{ ds.name }}_attrs.insert(
            "{{ attr.name }}".to_string(),
            Attribute::new(
                {{ attr.field_type | sdk_attr_type }},
                AttributeFlags::computed(),
            ){% if attr.description %}.with_description("{{ attr.description }}"){% endif %},
        );
{% endfor %}

        data_sources.insert(
            "{{ service.name }}_{{ ds.name }}".to_string(),
            Schema {
                version: 1,
                block: Block {
                    attributes: {{ service.name }}_{{ ds.name }}_attrs,
                    blocks: HashMap::new(),
                    description: {% if ds.description %}Some("{{ ds.description }}".to_string()){% else %}None{% endif %},
                },
            },
        );
{% endfor %}
{% endfor %}

        data_sources
    }
}

impl Default for {{ provider_name | capitalize }}Provider {
    fn default() -> Self {
        Self::new()
    }
}

// Helper methods for {{ provider_name | capitalize }}Provider
impl {{ provider_name | capitalize }}Provider {
    /// Check if any immutable fields have changed between prior and proposed states
    fn has_immutable_field_changes(
        &self,
        resource_type: &str,
        prior: &serde_json::Value,
        proposed: &serde_json::Value,
    ) -> bool {
        // Get immutable fields for this resource type
        let immutable_fields: &[&str] = match resource_type {
{% for service in services %}
{% for resource in service.resources %}
            "{{ service.name }}_{{ resource.name }}" => &[
{% for field in resource.fields %}
{% if field.immutable %}
                "{{ field.name }}",
{% endif %}
{% endfor %}
            ],
{% endfor %}
{% endfor %}
            _ => &[],
        };

        // Check each immutable field for changes
        for field in immutable_fields {
            let prior_val = prior.get(*field);
            let proposed_val = proposed.get(*field);

            if prior_val != proposed_val {
                return true;
            }
        }

        false
    }
}

#[async_trait]
impl ProviderService for {{ provider_name | capitalize }}Provider {
    fn schema(&self) -> ProviderSchema {
        Self::build_schema()
    }

    async fn configure(&self, config: serde_json::Value) -> std::result::Result<Vec<Diagnostic>, ProviderError> {
        info!("Configuring {{ provider_name }} provider");
        debug!("Config: {:?}", config);

        // Initialize SDK config using provider-specific pattern
        let mut {{ sdk_config.config_codegen.config_var_name }} = {{ sdk_config.config_codegen.init_snippet }};

        // Apply optional configuration attributes
{% for attr in sdk_config.config_attrs %}
{% if attr.setter_snippet %}
        if let Some(val) = config.get("{{ attr.name }}").and_then(|v| v.{{ attr.value_extractor | default(value="as_str()") }}) {
            info!("Using {{ attr.name }}: {}", val);
            {{ attr.setter_snippet | replace(from="{value}", to="val") }};
        }
{% endif %}
{% endfor %}

        // Load the configuration
        let {{ sdk_config.config_codegen.loaded_config_var_name }} = {{ sdk_config.config_codegen.load_snippet }};

        // Initialize clients for all services
{% for service in services %}
        {
            let client = {{ sdk_config.config_codegen.client_from_config | replace(from="{client_type}", to=provider | client_type(service_name=service.name)) | replace(from="{config}", to=sdk_config.config_codegen.loaded_config_var_name) }};
            let mut guard = self.{{ service.name }}_client.write().await;
            *guard = Some(client);
            info!("{{ service.name }} client configured");
        }
{% endfor %}

        Ok(vec![])
    }

    async fn plan(
        &self,
        resource_type: &str,
        prior_state: Option<serde_json::Value>,
        proposed_state: serde_json::Value,
        config: serde_json::Value,
    ) -> std::result::Result<PlanResult, ProviderError> {
        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        // Compute diff between prior and proposed states
        let mut result = PlanResult::from_diff(prior_state.as_ref(), &proposed_state);

        // Check if any immutable fields changed (requires resource replacement)
        if let Some(ref prior) = prior_state {
            if self.has_immutable_field_changes(resource_type, prior, &proposed_state) {
                result.requires_replace = true;
            }
        }

        Ok(result)
    }

    async fn create(
        &self,
        resource_type: &str,
        planned_state: serde_json::Value,
    ) -> std::result::Result<serde_json::Value, ProviderError> {
        info!("Creating {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::create_resource(&resource_name, client, planned_state).await
{% else %}
                {{ service.name }}::create_resource(&resource_name, &self.config, planned_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn read(
        &self,
        resource_type: &str,
        current_state: serde_json::Value,
    ) -> std::result::Result<serde_json::Value, ProviderError> {
        debug!("Reading {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::read_resource(&resource_name, client, current_state).await
{% else %}
                {{ service.name }}::read_resource(&resource_name, &self.config, current_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn update(
        &self,
        resource_type: &str,
        prior_state: serde_json::Value,
        planned_state: serde_json::Value,
    ) -> std::result::Result<serde_json::Value, ProviderError> {
        info!("Updating {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::update_resource(&resource_name, client, planned_state).await
{% else %}
                {{ service.name }}::update_resource(&resource_name, &self.config, planned_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn delete(
        &self,
        resource_type: &str,
        current_state: serde_json::Value,
    ) -> std::result::Result<(), ProviderError> {
        info!("Deleting {} resource", resource_type);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!("Invalid resource type: {}", resource_type)));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::delete_resource(&resource_name, client, current_state).await
{% else %}
                {{ service.name }}::delete_resource(&resource_name, &self.config, current_state).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!("Unknown service: {}", service_name))),
        }
    }

    async fn import_resource(
        &self,
        resource_type: &str,
        id: &str,
    ) -> std::result::Result<Vec<ImportedResource>, ProviderError> {
        info!("Importing {} resource with id: {}", resource_type, id);

        // Parse resource type: service_resource format
        let parts: Vec<&str> = resource_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!(
                "Invalid resource type: {}",
                resource_type
            )));
        }

        let service_name = parts[0];
        let resource_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::import_resource(&resource_name, client, id).await
{% else %}
                {{ service.name }}::import_resource(&resource_name, &self.config, id).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }

    async fn read_data_source(
        &self,
        data_source_type: &str,
        config: serde_json::Value,
    ) -> std::result::Result<serde_json::Value, ProviderError> {
        info!("Reading {} data source", data_source_type);

        // Parse data source type: service_datasource format
        let parts: Vec<&str> = data_source_type.split('_').collect();
        if parts.len() < 2 {
            return Err(ProviderError::Validation(format!(
                "Invalid data source type: {}",
                data_source_type
            )));
        }

        let service_name = parts[0];
        let ds_name = parts[1..].join("_");

        match service_name {
{% for service in services %}
            "{{ service.name }}" => {
{% if provider | has_config_crate %}
                let client = self.get_{{ service.name }}_client().await?;
                {{ service.name }}::read_data_source(&ds_name, client, config).await
{% else %}
                {{ service.name }}::read_data_source(&ds_name, &self.config, config).await
{% endif %}
            }
{% endfor %}
            _ => Err(ProviderError::UnknownResource(format!(
                "Unknown service: {}",
                service_name
            ))),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_provider_creation() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
        assert!(!schema.resources.is_empty());
    }

    #[test]
    fn test_schema_has_resources() {
        let provider = {{ provider_name | capitalize }}Provider::new();
        let schema = provider.schema();
{% for service in services %}
{% for resource in service.resources %}
        assert!(
            schema.resources.contains_key("{{ service.name }}_{{ resource.name }}"),
            "Schema should contain {{ service.name }}_{{ resource.name }}"
        );
{% endfor %}
{% endfor %}
    }
}
